{"version":3,"sources":["../src/oai/parser.ts","../src/oai/stream.ts","../src/structured-stream.client.ts","../src/lib/index.ts","../src/oai/params.ts","../src/response-model.ts","../src/constants/modes.ts","../src/create-agent.ts","../src/lib/_utils.ts","../src/index.ts"],"sourcesContent":["import OpenAI from \"openai\"\n\n/**\n * `OAIResponseFnArgsParser` parses a JSON string and extracts the function call arguments.\n *\n * @param {string} data - The JSON string to parse.\n * @returns {string} - The extracted function arguments.\n *\n */\nexport function OAIResponseFnArgsParser(\n  data:\n    | string\n    | OpenAI.Chat.Completions.ChatCompletionChunk\n    | OpenAI.Chat.Completions.ChatCompletion\n): string {\n  const parsedData = typeof data === \"string\" ? JSON.parse(data) : data\n  const text =\n    parsedData.choices?.[0]?.delta?.function_call?.arguments ??\n    parsedData.choices?.[0]?.message?.function_call?.arguments ??\n    \"\"\n\n  return text\n}\n\n/**\n * `OAIResponseToolArgsParser` parses a JSON string and extracts the tool call arguments.\n *\n * @param {string} data - The JSON string to parse.\n * @returns {Objstringect} - The extracted tool call arguments.\n *\n */\nexport function OAIResponseToolArgsParser(\n  data:\n    | string\n    | OpenAI.Chat.Completions.ChatCompletionChunk\n    | OpenAI.Chat.Completions.ChatCompletion\n): string {\n  const parsedData = typeof data === \"string\" ? JSON.parse(data) : data\n\n  const text =\n    parsedData.choices?.[0]?.delta?.tool_calls?.[0]?.function?.arguments ??\n    parsedData.choices?.[0]?.message?.tool_calls?.[0]?.function?.arguments ??\n    \"\"\n\n  return text\n}\n\n/**\n * `OAIResponseJSONParser` parses a JSON string and extracts the JSON content.\n *\n * @param {string} data - The JSON string to parse.\n * @returns {string} - The extracted JSON content.\n *\n *\n */\nexport function OAIResponseJSONParser(\n  data:\n    | string\n    | OpenAI.Chat.Completions.ChatCompletionChunk\n    | OpenAI.Chat.Completions.ChatCompletion\n): string {\n  const parsedData = typeof data === \"string\" ? JSON.parse(data) : data\n\n  const text =\n    parsedData.choices?.[0]?.delta?.content ?? parsedData?.choices?.[0]?.message?.content ?? \"\"\n\n  const jsonRegex = /```json\\n([\\s\\S]*?)\\n```/\n  const match = text.match(jsonRegex)\n\n  return match ? match[1] : text\n}\n\n/**\n * `OAIResponseParser` parses a JSON string or a response object.\n * It checks if the input contains function call arguments. If it does,\n * it uses `OAIResponseFnArgsParser` to parse the input, otherwise, it uses `OAIResponseTextParser`.\n *\n * @param {string | Stream<OpenAI.Chat.Completions.ChatCompletionChunk> | OpenAI.Chat.Completions.ChatCompletion} data - The input to parse.\n * @returns {string} - The result of the appropriate parser.\n */\n\nexport function OAIResponseParser(\n  data:\n    | string\n    | OpenAI.Chat.Completions.ChatCompletionChunk\n    | OpenAI.Chat.Completions.ChatCompletion\n): string {\n  const parsedData = typeof data === \"string\" ? JSON.parse(data) : data\n\n  const isFnCall =\n    parsedData.choices?.[0]?.delta?.function_call?.arguments ||\n    parsedData.choices?.[0]?.message?.function_call?.arguments ||\n    false\n\n  const isToolCall =\n    parsedData.choices?.[0]?.delta?.tool_calls?.[0]?.function?.arguments ??\n    parsedData.choices?.[0]?.message?.tool_calls?.[0]?.function?.arguments ??\n    false\n\n  if (isFnCall) {\n    return OAIResponseFnArgsParser(data)\n  }\n\n  if (isToolCall) {\n    return OAIResponseToolArgsParser(data)\n  }\n\n  return OAIResponseJSONParser(data)\n}\n","import OpenAI from \"openai\"\n\nimport { OAIResponseParser } from \"./parser\"\n\ninterface OaiStreamArgs {\n  res: AsyncIterable<OpenAI.ChatCompletionChunk>\n}\n\nfunction stripControlCharacters(str: string): string {\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, \"\")\n}\n\n/**\n * `OaiStream` creates a ReadableStream that parses the SSE response from OAI\n * and returns a parsed string from the response.\n *\n * @param {OaiStreamArgs} args - The arguments for the function.\n * @returns {ReadableStream<string>} - The created ReadableStream.\n */\nexport function OAIStream({ res }: OaiStreamArgs): ReadableStream<Uint8Array> {\n  let cancelGenerator: () => void\n  const encoder = new TextEncoder()\n\n  async function* generateStream(\n    res: AsyncIterable<OpenAI.ChatCompletionChunk>\n  ): AsyncGenerator<string> {\n    let cancel = false\n    cancelGenerator = () => {\n      cancel = true\n      return\n    }\n\n    for await (const part of res) {\n      if (cancel) {\n        break\n      }\n\n      if (!OAIResponseParser(part)) {\n        continue\n      }\n\n      yield OAIResponseParser(part)\n    }\n  }\n\n  const generator = generateStream(res)\n\n  return new ReadableStream({\n    async start(controller) {\n      for await (const parsedData of generator) {\n        controller.enqueue(encoder.encode(stripControlCharacters(parsedData)))\n      }\n\n      controller.close()\n    },\n    cancel() {\n      if (cancelGenerator) {\n        cancelGenerator()\n      }\n    }\n  })\n}\n\n/**\n * `readableStreamToAsyncGenerator` converts a ReadableStream to an AsyncGenerator.\n *\n * @param {ReadableStream<Uint8Array>} stream - The ReadableStream to convert.\n * @returns {AsyncGenerator<unknown>} - The converted AsyncGenerator.\n */\nexport async function* readableStreamToAsyncGenerator(\n  stream: ReadableStream<Uint8Array>\n): AsyncGenerator<unknown> {\n  const reader = stream.getReader()\n  const decoder = new TextDecoder()\n\n  while (true) {\n    const { done, value } = await reader.read()\n\n    if (done) {\n      break\n    }\n\n    // stripping a second time to be safe.\n    const decodedString = stripControlCharacters(decoder.decode(value))\n    yield JSON.parse(decodedString)\n  }\n\n  return\n}\n","import { readableStreamToAsyncGenerator } from \"@/oai/stream\"\nimport {\n  ActivePath,\n  ClientConfig,\n  CompletedPaths,\n  CompletionMeta,\n  LogLevel,\n  ZodStreamCompletionParams\n} from \"@/types\"\nimport { SchemaStream } from \"schema-stream\"\nimport { z } from \"zod\"\n\nexport default class ZodStream {\n  readonly debug: boolean = false\n\n  constructor({ debug = false }: ClientConfig = {}) {\n    this.debug = debug\n  }\n\n  private log<T extends unknown[]>(level: LogLevel, ...args: T) {\n    if (!this.debug && level === \"debug\") {\n      return\n    }\n\n    const timestamp = new Date().toISOString()\n    switch (level) {\n      case \"debug\":\n        console.debug(`[ZodStream-CLIENT:DEBUG] ${timestamp}:`, ...args)\n        break\n      case \"info\":\n        console.info(`[ZodStream-CLIENT:INFO] ${timestamp}:`, ...args)\n        break\n      case \"warn\":\n        console.warn(`[ZodStream-CLIENT:WARN] ${timestamp}:`, ...args)\n        break\n      case \"error\":\n        console.error(`[ZodStream-CLIENT:ERROR] ${timestamp}:`, ...args)\n        break\n    }\n  }\n\n  private async chatCompletionStream<T extends z.AnyZodObject>({\n    completionPromise,\n    data,\n    response_model\n  }: ZodStreamCompletionParams<T>): Promise<\n    AsyncGenerator<Partial<z.infer<T>> & { _meta: CompletionMeta }, void, unknown>\n  > {\n    let _activePath: ActivePath = []\n    let _completedPaths: CompletedPaths = []\n\n    this.log(\"debug\", \"Starting completion stream\")\n\n    const streamParser = new SchemaStream(response_model.schema, {\n      typeDefaults: {\n        string: null,\n        number: null,\n        boolean: null\n      },\n      onKeyComplete: ({ activePath, completedPaths }) => {\n        this.log(\"debug\", \"Key complete\", activePath, completedPaths)\n        _activePath = activePath\n        _completedPaths = completedPaths\n      }\n    })\n\n    try {\n      const parser = streamParser.parse({\n        handleUnescapedNewLines: true\n      })\n\n      const textEncoder = new TextEncoder()\n      const textDecoder = new TextDecoder()\n\n      const validationStream = new TransformStream({\n        transform: async (chunk, controller): Promise<void> => {\n          try {\n            const parsedChunk = JSON.parse(textDecoder.decode(chunk))\n            const validation = await response_model.schema.safeParseAsync(parsedChunk)\n\n            this.log(\"debug\", \"Validation result\", validation)\n\n            controller.enqueue(\n              textEncoder.encode(\n                JSON.stringify({\n                  ...parsedChunk,\n                  _meta: {\n                    _isValid: validation.success,\n                    _activePath,\n                    _completedPaths\n                  }\n                })\n              )\n            )\n          } catch (e) {\n            this.log(\"error\", \"Error in the partial stream validation stream\", e, chunk)\n            controller.error(e)\n          }\n        },\n        flush() {}\n      })\n\n      const stream = await completionPromise(data)\n\n      if (!stream) {\n        this.log(\"error\", \"Completion call returned no data\")\n        throw new Error(stream)\n      }\n\n      stream.pipeThrough(parser)\n      parser.readable.pipeThrough(validationStream)\n\n      return readableStreamToAsyncGenerator(validationStream.readable) as AsyncGenerator<\n        Partial<z.infer<T>> & { _meta: CompletionMeta },\n        void,\n        unknown\n      >\n    } catch (error) {\n      this.log(\"error\", \"Error making completion call\")\n      throw error\n    }\n  }\n\n  public getSchemaStub({\n    schema,\n    defaultData = {}\n  }: {\n    schema: z.AnyZodObject\n    defaultData?: Partial<z.infer<typeof schema>>\n  }): Partial<z.infer<typeof schema>> {\n    const streamParser = new SchemaStream(schema, {\n      defaultData,\n      typeDefaults: {\n        string: null,\n        number: null,\n        boolean: null\n      }\n    })\n\n    return streamParser.getSchemaStub(schema, defaultData)\n  }\n\n  public async create<P extends ZodStreamCompletionParams<z.AnyZodObject>>(\n    params: P\n  ): Promise<\n    AsyncGenerator<\n      Partial<z.infer<P[\"response_model\"][\"schema\"]>> & { _meta: CompletionMeta },\n      void,\n      unknown\n    >\n  > {\n    return this.chatCompletionStream(params)\n  }\n}\n","export function omit<T extends object, K extends keyof T>(keys: K[], obj: T): Omit<T, K> {\n  const result = {} as Omit<T, K>\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key) && !keys.includes(key as unknown as K)) {\n      result[key as unknown as Exclude<keyof T, K>] = obj[key] as unknown as T[Exclude<keyof T, K>]\n    }\n  }\n  return result\n}\n","import { omit } from \"@/lib\"\nimport {\n  FunctionParamsReturnType,\n  JsonModeParamsReturnType,\n  JsonSchemaParamsReturnType,\n  MessageBasedParamsReturnType,\n  ParseParams,\n  ToolFunctionParamsReturnType\n} from \"@/types\"\nimport OpenAI from \"openai\"\n\nexport function OAIBuildFunctionParams<T extends OpenAI.ChatCompletionCreateParams>(\n  definition: ParseParams,\n  params: T\n): FunctionParamsReturnType<T> {\n  const { name, description, ...definitionParams } = definition\n\n  const function_call: OpenAI.ChatCompletionFunctionCallOption = {\n    name\n  }\n\n  const functions: OpenAI.FunctionDefinition[] = [\n    ...(params?.functions ?? []),\n    {\n      name: name,\n      description: description ?? undefined,\n      parameters: definitionParams\n    }\n  ]\n\n  return {\n    ...params,\n    function_call,\n    functions\n  }\n}\n\nexport function OAIBuildToolFunctionParams<T extends OpenAI.ChatCompletionCreateParams>(\n  definition: ParseParams,\n  params: T\n): ToolFunctionParamsReturnType<T> {\n  const { name, description, ...definitionParams } = definition\n\n  const tool_choice: OpenAI.ChatCompletionToolChoiceOption = {\n    type: \"function\",\n    function: { name }\n  }\n\n  const tools: OpenAI.ChatCompletionTool[] = [\n    {\n      type: \"function\",\n      function: {\n        name: name,\n        description: description,\n        parameters: definitionParams\n      }\n    },\n    ...(params.tools?.map(\n      (tool): OpenAI.ChatCompletionTool => ({\n        type: tool.type,\n        function: {\n          name: tool.function.name,\n          description: tool.function.description,\n          parameters: tool.function.parameters\n        }\n      })\n    ) ?? [])\n  ]\n\n  return {\n    ...params,\n    tool_choice,\n    tools\n  }\n}\n\nexport function OAIBuildMessageBasedParams<T extends OpenAI.ChatCompletionCreateParams>(\n  definition: ParseParams,\n  params: T\n): MessageBasedParamsReturnType<T> {\n  return {\n    ...params,\n    messages: [\n      {\n        role: \"system\",\n        content: `\n          Given a user prompt, you will return fully valid JSON based on the following description and schema.\n          You will return no other prose. You will take into account any descriptions or required parameters within the schema\n          and return a valid and fully escaped JSON object that matches the schema and those instructions.\n\n          description: ${definition.description}\n          json schema: ${JSON.stringify(definition)}\n        `\n      },\n      ...params.messages\n    ]\n  }\n}\n\nexport function OAIBuildJsonModeParams<T extends OpenAI.ChatCompletionCreateParams>(\n  definition: ParseParams,\n  params: T\n): JsonModeParamsReturnType<T> {\n  return {\n    ...params,\n    response_format: { type: \"json_object\" },\n    messages: [\n      {\n        role: \"system\",\n        content: `\n          Given a user prompt, you will return fully valid JSON based on the following description and schema.\n          You will return no other prose. You will take into account any descriptions or required parameters within the schema\n          and return a valid and fully escaped JSON object that matches the schema and those instructions.\n\n          description: ${definition.description}\n          json schema: ${JSON.stringify(definition)}\n        `\n      },\n      ...params.messages\n    ]\n  }\n}\n\nexport function OAIBuildJsonSchemaParams<T extends OpenAI.ChatCompletionCreateParams>(\n  definition: ParseParams,\n  params: T\n): JsonSchemaParamsReturnType<T> {\n  return {\n    ...params,\n    response_format: {\n      type: \"json_object\",\n      schema: omit([\"name\", \"description\"], definition)\n    },\n    messages: [\n      {\n        role: \"system\",\n        content: `\n          Given a user prompt, you will return fully valid JSON based on the following description.\n          You will return no other prose. You will take into account any descriptions or required parameters within the schema\n          and return a valid and fully escaped JSON object that matches the schema and those instructions.\n\n          description: ${definition.description}\n        `\n      },\n      ...params.messages\n    ]\n  }\n}\n","import {\n  OAIBuildFunctionParams,\n  OAIBuildJsonModeParams,\n  OAIBuildJsonSchemaParams,\n  OAIBuildMessageBasedParams,\n  OAIBuildToolFunctionParams\n} from \"@/oai/params\"\nimport OpenAI from \"openai\"\nimport { z } from \"zod\"\nimport zodToJsonSchema from \"zod-to-json-schema\"\n\nimport { MODE } from \"@/constants/modes\"\n\nimport { Mode, ModeParamsReturnType, ResponseModel } from \"./types\"\n\nexport function withResponseModel<\n  T extends z.AnyZodObject,\n  M extends Mode,\n  P extends OpenAI.ChatCompletionCreateParams\n>({\n  response_model: { name, schema, description = \"\" },\n  mode,\n  params\n}: {\n  response_model: ResponseModel<T>\n  mode: M\n  params: P\n}): ModeParamsReturnType<P, M> {\n  const safeName = name.replace(/[^a-zA-Z0-9]/g, \"_\").replace(/\\s/g, \"_\")\n\n  const { definitions } = zodToJsonSchema(schema, {\n    name: safeName,\n    errorMessages: true\n  })\n\n  if (!definitions || !definitions?.[safeName]) {\n    console.warn(\"Could not extract json schema definitions from your schema\", schema)\n    throw new Error(\"Could not extract json schema definitions from your schema\")\n  }\n\n  const definition = {\n    name: safeName,\n    description,\n    ...definitions[safeName]\n  }\n\n  if (mode === MODE.FUNCTIONS) {\n    return OAIBuildFunctionParams<P>(definition, params) as ModeParamsReturnType<P, M>\n  }\n\n  if (mode === MODE.TOOLS) {\n    return OAIBuildToolFunctionParams<P>(definition, params) as ModeParamsReturnType<P, M>\n  }\n\n  if (mode === MODE.JSON) {\n    return OAIBuildJsonModeParams<P>(definition, params) as ModeParamsReturnType<P, M>\n  }\n\n  if (mode === MODE.JSON_SCHEMA) {\n    return OAIBuildJsonSchemaParams<P>(definition, params) as ModeParamsReturnType<P, M>\n  }\n\n  if (mode === MODE.MD_JSON) {\n    return OAIBuildMessageBasedParams<P>(definition, params) as ModeParamsReturnType<P, M>\n  }\n\n  return OAIBuildMessageBasedParams<P>(definition, params) as ModeParamsReturnType<P, M>\n}\n","export const MODE = {\n  FUNCTIONS: \"FUNCTIONS\",\n  TOOLS: \"TOOLS\",\n  JSON: \"JSON\",\n  MD_JSON: \"MD_JSON\",\n  JSON_SCHEMA: \"JSON_SCHEMA\"\n} as const\n","import OpenAI from \"openai\"\nimport { z } from \"zod\"\n\nimport { OAIResponseParser } from \"./oai/parser\"\nimport { OAIStream } from \"./oai/stream\"\nimport { withResponseModel } from \"./response-model\"\nimport { Mode } from \"./types\"\n\nexport type CreateAgentParams = {\n  defaultClientOptions: Partial<OpenAI.ChatCompletionCreateParams> & {\n    model: OpenAI.ChatCompletionCreateParams[\"model\"]\n    messages: OpenAI.ChatCompletionMessageParam[]\n  }\n  /**\n   * Mode to use\n   * @default \"TOOLS\"\n   *\n   * @type {Mode}\n   * */\n  mode?: Mode\n  /**\n   * OpenAI client instance\n   * @default new OpenAI()\n   *\n   * @type {OpenAI}\n   * */\n  client?: OpenAI\n  response_model: {\n    schema: z.AnyZodObject\n    name: string\n  }\n}\n\nexport type AgentInstance = ReturnType<typeof createAgent>\nexport type ConfigOverride = Partial<OpenAI.ChatCompletionCreateParams>\n\n/**\n * Create a pre-configured \"agent\" that can be used to generate completions\n * Messages that are passed at initialization will be pre-pended to all completions\n * all other configuration can be overriden in the completion call.\n *\n * @param {CreateAgentParams} params\n *\n * @returns {AgentInstance}\n */\nexport function createAgent({\n  defaultClientOptions,\n  response_model,\n  mode = \"TOOLS\",\n  client\n}: CreateAgentParams) {\n  const defaultAgentParams = {\n    temperature: 0.7,\n    top_p: 1,\n    frequency_penalty: 0,\n    presence_penalty: 0,\n    n: 1,\n    ...defaultClientOptions\n  }\n\n  if (!client) {\n    throw new Error(\"an OpenAI-like client is required\")\n  }\n\n  const oai = client\n\n  return {\n    /**\n     * Generate a single stream completion\n     * @param {ConfigOverride}\n     *\n     * @returns {Promise<ReadableStream<Uint8Array>> }\n     */\n    completionStream: async (\n      configOverride: ConfigOverride\n    ): Promise<ReadableStream<Uint8Array>> => {\n      const messages = [\n        ...(defaultAgentParams.messages ?? []),\n        ...(configOverride?.messages ?? [])\n      ] as OpenAI.ChatCompletionMessageParam[]\n\n      const params = withResponseModel({\n        mode,\n        response_model,\n        params: {\n          ...defaultAgentParams,\n          ...configOverride,\n          stream: true,\n          messages\n        }\n      })\n\n      const extractionStream = await oai.chat.completions.create(params)\n\n      return OAIStream({\n        res: extractionStream\n      })\n    },\n    /**\n     * Generate a standard completion\n     * @param {ConfigOverride}\n     *\n     * @returns {Promise<z.infer<typeof response_model.schema>> }\n     */\n    completion: async (\n      configOverride: ConfigOverride\n    ): Promise<z.infer<typeof response_model.schema>> => {\n      const messages = [\n        ...(defaultAgentParams.messages ?? []),\n        ...(configOverride?.messages ?? [])\n      ] as OpenAI.ChatCompletionMessageParam[]\n\n      const params = withResponseModel({\n        mode,\n        response_model,\n        params: {\n          ...defaultAgentParams,\n          ...configOverride,\n          stream: false,\n          messages\n        }\n      })\n\n      const res = await oai.chat.completions.create(params)\n      const extractedResponse = OAIResponseParser(res)\n\n      return JSON.parse(extractedResponse)\n    }\n  }\n}\n","import { ActivePath, CompletionMeta } from \"..\"\n\nexport function isPathComplete(activePath: ActivePath, data: { _meta: CompletionMeta }): boolean {\n  const { _completedPaths } = data?._meta ?? {}\n\n  return _completedPaths.some(completedPath => {\n    if (completedPath.length !== activePath.length) {\n      return false\n    }\n\n    return completedPath.every((compPathElement, index) => {\n      const activePathElement = activePath[index]\n\n      if (compPathElement === undefined || activePathElement === undefined) {\n        return true\n      }\n      return compPathElement === activePathElement\n    })\n  })\n}\n","import ZodStream from \"./structured-stream.client\"\n\nexport * from \"./response-model\"\nexport * from \"./oai/parser\"\nexport * from \"./oai/stream\"\nexport * from \"./constants/modes\"\nexport * from \"./types\"\nexport * from \"./create-agent\"\nexport * from \"./lib/_utils\"\n\nexport default ZodStream\n"],"mappings":"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","names":["OAIResponseFnArgsParser","data","parsedData","OAIResponseToolArgsParser","OAIResponseJSONParser","text","jsonRegex","match","OAIResponseParser","isFnCall","isToolCall","stripControlCharacters","str","OAIStream","res","cancelGenerator","encoder","generateStream","cancel","part","OAIResponseParser","generator","controller","parsedData","readableStreamToAsyncGenerator","stream","reader","decoder","done","value","decodedString","SchemaStream","ZodStream","debug","level","args","timestamp","completionPromise","data","response_model","_activePath","_completedPaths","streamParser","activePath","completedPaths","parser","textEncoder","textDecoder","validationStream","chunk","controller","parsedChunk","validation","e","stream","readableStreamToAsyncGenerator","error","schema","defaultData","params","omit","keys","obj","result","key","OAIBuildFunctionParams","definition","params","name","description","definitionParams","function_call","functions","OAIBuildToolFunctionParams","tool_choice","tools","tool","OAIBuildMessageBasedParams","OAIBuildJsonModeParams","OAIBuildJsonSchemaParams","omit","zodToJsonSchema","MODE","withResponseModel","name","schema","description","mode","params","safeName","definitions","zodToJsonSchema","definition","MODE","OAIBuildFunctionParams","OAIBuildToolFunctionParams","OAIBuildJsonModeParams","OAIBuildJsonSchemaParams","OAIBuildMessageBasedParams","createAgent","defaultClientOptions","response_model","mode","client","defaultAgentParams","oai","configOverride","messages","params","withResponseModel","extractionStream","OAIStream","res","extractedResponse","OAIResponseParser","isPathComplete","activePath","data","_completedPaths","completedPath","compPathElement","index","activePathElement","src_default","ZodStream"]}