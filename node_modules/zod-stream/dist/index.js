function R(t){let e=typeof t=="string"?JSON.parse(t):t;return e.choices?.[0]?.delta?.function_call?.arguments??e.choices?.[0]?.message?.function_call?.arguments??""}function _(t){let e=typeof t=="string"?JSON.parse(t):t;return e.choices?.[0]?.delta?.tool_calls?.[0]?.function?.arguments??e.choices?.[0]?.message?.tool_calls?.[0]?.function?.arguments??""}function J(t){let e=typeof t=="string"?JSON.parse(t):t,o=e.choices?.[0]?.delta?.content??e?.choices?.[0]?.message?.content??"",n=/```json\n([\s\S]*?)\n```/,r=o.match(n);return r?r[1]:o}function u(t){let e=typeof t=="string"?JSON.parse(t):t,o=e.choices?.[0]?.delta?.function_call?.arguments||e.choices?.[0]?.message?.function_call?.arguments||!1,n=e.choices?.[0]?.delta?.tool_calls?.[0]?.function?.arguments??e.choices?.[0]?.message?.tool_calls?.[0]?.function?.arguments??!1;return o?R(t):n?_(t):J(t)}function A(t){return t.replace(/[\x00-\x1F\x7F-\x9F]/g,"")}function T({res:t}){let e,o=new TextEncoder;async function*n(s){let i=!1;e=()=>{i=!0};for await(let a of s){if(i)break;u(a)&&(yield u(a))}}let r=n(t);return new ReadableStream({async start(s){for await(let i of r)s.enqueue(o.encode(A(i)));s.close()},cancel(){e&&e()}})}async function*S(t){let e=t.getReader(),o=new TextDecoder;for(;;){let{done:n,value:r}=await e.read();if(n)break;let s=A(o.decode(r));yield JSON.parse(s)}}import{SchemaStream as I}from"schema-stream";var d=class{constructor({debug:e=!1}={}){this.debug=!1;this.debug=e}log(e,...o){if(!this.debug&&e==="debug")return;let n=new Date().toISOString();switch(e){case"debug":console.debug(`[ZodStream-CLIENT:DEBUG] ${n}:`,...o);break;case"info":console.info(`[ZodStream-CLIENT:INFO] ${n}:`,...o);break;case"warn":console.warn(`[ZodStream-CLIENT:WARN] ${n}:`,...o);break;case"error":console.error(`[ZodStream-CLIENT:ERROR] ${n}:`,...o);break}}async chatCompletionStream({completionPromise:e,data:o,response_model:n}){let r=[],s=[];this.log("debug","Starting completion stream");let i=new I(n.schema,{typeDefaults:{string:null,number:null,boolean:null},onKeyComplete:({activePath:a,completedPaths:m})=>{this.log("debug","Key complete",a,m),r=a,s=m}});try{let a=i.parse({handleUnescapedNewLines:!0}),m=new TextEncoder,p=new TextDecoder,f=new TransformStream({transform:async(P,g)=>{try{let l=JSON.parse(p.decode(P)),y=await n.schema.safeParseAsync(l);this.log("debug","Validation result",y),g.enqueue(m.encode(JSON.stringify({...l,_meta:{_isValid:y.success,_activePath:r,_completedPaths:s}})))}catch(l){this.log("error","Error in the partial stream validation stream",l,P),g.error(l)}},flush(){}}),h=await e(o);if(!h)throw this.log("error","Completion call returned no data"),new Error(h);return h.pipeThrough(a),a.readable.pipeThrough(f),S(f.readable)}catch(a){throw this.log("error","Error making completion call"),a}}getSchemaStub({schema:e,defaultData:o={}}){return new I(e,{defaultData:o,typeDefaults:{string:null,number:null,boolean:null}}).getSchemaStub(e,o)}async create(e){return this.chatCompletionStream(e)}};function x(t,e){let o={};for(let n in e)e.hasOwnProperty(n)&&!t.includes(n)&&(o[n]=e[n]);return o}function w(t,e){let{name:o,description:n,...r}=t,s={name:o},i=[...e?.functions??[],{name:o,description:n??void 0,parameters:r}];return{...e,function_call:s,functions:i}}function M(t,e){let{name:o,description:n,...r}=t,s={type:"function",function:{name:o}},i=[{type:"function",function:{name:o,description:n,parameters:r}},...e.tools?.map(a=>({type:a.type,function:{name:a.function.name,description:a.function.description,parameters:a.function.parameters}}))??[]];return{...e,tool_choice:s,tools:i}}function C(t,e){return{...e,messages:[{role:"system",content:`
          Given a user prompt, you will return fully valid JSON based on the following description and schema.
          You will return no other prose. You will take into account any descriptions or required parameters within the schema
          and return a valid and fully escaped JSON object that matches the schema and those instructions.

          description: ${t.description}
          json schema: ${JSON.stringify(t)}
        `},...e.messages]}}function b(t,e){return{...e,response_format:{type:"json_object"},messages:[{role:"system",content:`
          Given a user prompt, you will return fully valid JSON based on the following description and schema.
          You will return no other prose. You will take into account any descriptions or required parameters within the schema
          and return a valid and fully escaped JSON object that matches the schema and those instructions.

          description: ${t.description}
          json schema: ${JSON.stringify(t)}
        `},...e.messages]}}function N(t,e){return{...e,response_format:{type:"json_object",schema:x(["name","description"],t)},messages:[{role:"system",content:`
          Given a user prompt, you will return fully valid JSON based on the following description.
          You will return no other prose. You will take into account any descriptions or required parameters within the schema
          and return a valid and fully escaped JSON object that matches the schema and those instructions.

          description: ${t.description}
        `},...e.messages]}}import k from"zod-to-json-schema";var c={FUNCTIONS:"FUNCTIONS",TOOLS:"TOOLS",JSON:"JSON",MD_JSON:"MD_JSON",JSON_SCHEMA:"JSON_SCHEMA"};function O({response_model:{name:t,schema:e,description:o=""},mode:n,params:r}){let s=t.replace(/[^a-zA-Z0-9]/g,"_").replace(/\s/g,"_"),{definitions:i}=k(e,{name:s,errorMessages:!0});if(!i||!i?.[s])throw console.warn("Could not extract json schema definitions from your schema",e),new Error("Could not extract json schema definitions from your schema");let a={name:s,description:o,...i[s]};return n===c.FUNCTIONS?w(a,r):n===c.TOOLS?M(a,r):n===c.JSON?b(a,r):n===c.JSON_SCHEMA?N(a,r):n===c.MD_JSON?C(a,r):C(a,r)}function W({defaultClientOptions:t,response_model:e,mode:o="TOOLS",client:n}){let r={temperature:.7,top_p:1,frequency_penalty:0,presence_penalty:0,n:1,...t};if(!n)throw new Error("an OpenAI-like client is required");let s=n;return{completionStream:async i=>{let a=[...r.messages??[],...i?.messages??[]],m=O({mode:o,response_model:e,params:{...r,...i,stream:!0,messages:a}}),p=await s.chat.completions.create(m);return T({res:p})},completion:async i=>{let a=[...r.messages??[],...i?.messages??[]],m=O({mode:o,response_model:e,params:{...r,...i,stream:!1,messages:a}}),p=await s.chat.completions.create(m),f=u(p);return JSON.parse(f)}}}function X(t,e){let{_completedPaths:o}=e?._meta??{};return o.some(n=>n.length!==t.length?!1:n.every((r,s)=>{let i=t[s];return r===void 0||i===void 0?!0:r===i}))}var ne=d;export{c as MODE,R as OAIResponseFnArgsParser,J as OAIResponseJSONParser,u as OAIResponseParser,_ as OAIResponseToolArgsParser,T as OAIStream,W as createAgent,ne as default,X as isPathComplete,S as readableStreamToAsyncGenerator,O as withResponseModel};
//# sourceMappingURL=index.js.map