{"version":3,"sources":["../src/index.ts","../src/utils/streaming-json-parser.ts","../src/utils/token-type.ts","../src/utils/token-parser.ts","../src/utils/buffered-string.ts","../src/utils/utf-8.ts","../src/utils/tokenizer.ts","../src/utils/json-parser.ts"],"sourcesContent":["export * from \"./utils/streaming-json-parser\"\n","import { lensPath, set, view } from \"ramda\"\nimport { z, ZodObject, ZodOptional, ZodRawShape, ZodTypeAny } from \"zod\"\n\nimport JSONParser from \"./json-parser\"\nimport { ParsedTokenInfo, StackElement, TokenParserMode, TokenParserState } from \"./token-parser\"\n\ntype SchemaType<T extends ZodRawShape = ZodRawShape> = ZodObject<T>\ntype TypeDefaults = {\n  string?: string | null | undefined\n  number?: number | null | undefined\n  boolean?: boolean | null | undefined\n}\n\ntype NestedValue = string | number | boolean | NestedObject | NestedValue[]\ntype NestedObject = { [key: string]: NestedValue } & { [key: number]: NestedValue }\n\ntype OnKeyCompleteCallbackParams = {\n  activePath: (string | number | undefined)[]\n  completedPaths: (string | number | undefined)[][]\n}\n\ntype OnKeyCompleteCallback = (data: OnKeyCompleteCallbackParams) => void | undefined\n\n/**\n * `SchemaStream` is a utility for parsing streams of json and\n * providing a safe-to-read-from stubbed version of the data before the stream\n * has fully completed.\n *\n * It uses Zod for schema validation and the Streamparser library for\n * parsing JSON from an input stream.\n *\n * @example\n * ```typescript\n * const schema = z.object({\n *   someString: z.string(),\n *   someNumber: z.number()\n * })\n *\n * const response = await getSomeStreamOfJson()\n * const parser = new SchemaStream(schema)\n * const streamParser = parser.parse()\n *\n * response.body?.pipeThrough(parser)\n *\n * const reader = streamParser.readable.getReader()\n *\n * const decoder = new TextDecoder()\n * let result = {}\n * while (!done) {\n *   const { value, done: doneReading } = await reader.read()\n *   done = doneReading\n *\n *   if (done) {\n *     console.log(result)\n *     break\n *   }\n *\n *   const chunkValue = decoder.decode(value)\n *   result = JSON.parse(chunkValue)\n * }\n * ```\n *\n * @public\n */\n\nexport class SchemaStream {\n  private schemaInstance: NestedObject\n  private activePath: (string | number | undefined)[] = []\n  private completedPaths: (string | number | undefined)[][] = []\n  private onKeyComplete?: OnKeyCompleteCallback\n\n  /**\n   * Constructs a new instance of the `SchemaStream` class.\n   *\n   * @param schema - The Zod schema to use for validation.\n   */\n  constructor(\n    schema: SchemaType,\n    opts: {\n      defaultData?: NestedObject\n      typeDefaults?: TypeDefaults\n      onKeyComplete?: OnKeyCompleteCallback\n    } = {}\n  ) {\n    const { defaultData, onKeyComplete, typeDefaults } = opts\n\n    this.schemaInstance = this.createBlankObject(schema, defaultData, typeDefaults)\n    this.onKeyComplete = onKeyComplete\n  }\n\n  /**\n   * Gets the default value for a given Zod type.\n   *\n   * Full set of first-party Zod types can be found here:\n   * (https://github.com/colinhacks/zod/blob/master/src/types.ts#L4938C1-L4973C1)\n   *\n   * @param type - The Zod type.\n   * @returns The default value for the type.\n   */\n  private getDefaultValue(type: ZodTypeAny, typeDefaults?: TypeDefaults): unknown {\n    if (type?._def?.defaultValue) {\n      return type._def.defaultValue()\n    }\n\n    switch (type._def.typeName) {\n      case \"ZodDefault\":\n        return type._def.defaultValue()\n      case \"ZodString\":\n        return typeDefaults?.hasOwnProperty(\"string\") ? typeDefaults.string : null\n      case \"ZodNumber\":\n        return typeDefaults?.hasOwnProperty(\"number\") ? typeDefaults.number : null\n      case \"ZodBoolean\":\n        return typeDefaults?.hasOwnProperty(\"boolean\") ? typeDefaults.boolean : null\n      case \"ZodArray\":\n        return []\n      case \"ZodRecord\":\n        return {}\n      case \"ZodObject\":\n        return this.createBlankObject(type as SchemaType)\n      case \"ZodOptional\":\n        //eslint-disable-next-line\n        return this.getDefaultValue((type as ZodOptional<any>).unwrap())\n      case \"ZodEffects\":\n        return this.getDefaultValue(type._def.schema)\n      case \"ZodNullable\":\n        return null\n      case \"ZodEnum\":\n        return null\n      case \"ZodNativeEnum\":\n        return null\n      default:\n        console.warn(`No explicit default value for type: ${type._def.typeName} - returning null.`)\n        return null\n    }\n  }\n\n  private createBlankObject<T extends ZodRawShape>(\n    schema: SchemaType<T>,\n    defaultData?: NestedObject,\n    typeDefaults?: TypeDefaults\n  ): NestedObject {\n    const obj: NestedObject = {}\n\n    for (const key in schema.shape) {\n      const type = schema.shape[key]\n      if (defaultData && defaultData?.[key as unknown as keyof NestedObject]) {\n        obj[key] = defaultData?.[key as unknown as keyof NestedObject]\n      } else {\n        obj[key] = this.getDefaultValue(type, typeDefaults) as NestedValue\n      }\n    }\n\n    return obj\n  }\n\n  private getPathFromStack(\n    stack: StackElement[] = [],\n    key: string | number | undefined\n  ): (string | number)[] {\n    const valuePath = [...stack.map(({ key }) => key), key]\n    valuePath.shift()\n\n    // first item is undefined as root - we remove wiht shift t oavoid the full filter\n    // thats why we cast here\n    return valuePath as (string | number)[]\n  }\n\n  private handleToken({\n    parser: { key, stack },\n    tokenizer: { token, value, partial }\n  }: {\n    parser: {\n      state: TokenParserState\n      key: string | number | undefined\n      mode: TokenParserMode | undefined\n      stack: StackElement[]\n    }\n    tokenizer: ParsedTokenInfo\n  }): void {\n    if (this.activePath !== this.getPathFromStack(stack, key) || this.activePath.length === 0) {\n      this.activePath = this.getPathFromStack(stack, key)\n      !partial && this.completedPaths.push(this.activePath)\n      this.onKeyComplete &&\n        this.onKeyComplete({\n          activePath: this.activePath,\n          completedPaths: this.completedPaths\n        })\n    }\n\n    try {\n      const valuePath = this.getPathFromStack(stack, key)\n      const lens = lensPath(valuePath)\n\n      if (partial) {\n        let currentValue = view(lens, value) ?? \"\"\n        const updatedValue = `${currentValue}${value}`\n        const updatedSchemaInstance = set(lens, updatedValue, this.schemaInstance)\n        this.schemaInstance = updatedSchemaInstance\n      } else {\n        const updatedSchemaInstance = set(lens, value, this.schemaInstance)\n        this.schemaInstance = updatedSchemaInstance\n      }\n    } catch (e) {\n      console.error(`Error in the json parser onToken handler: token ${token} value ${value}`, e)\n    }\n  }\n\n  public getSchemaStub<T extends ZodRawShape>(\n    schema: SchemaType<T>,\n    defaultData?: NestedObject\n  ): z.infer<typeof schema> {\n    return this.createBlankObject(schema, defaultData) as z.infer<typeof schema>\n  }\n\n  /**\n   * Parses the JSON stream.\n   *\n   * @param {Object} opts - The options for parsing the JSON stream.\n   * @returns A `TransformStream` that can be used to process the JSON data.\n   */\n  public parse(\n    opts: {\n      stringBufferSize?: number\n      handleUnescapedNewLines?: boolean\n    } = { stringBufferSize: 0, handleUnescapedNewLines: true }\n  ) {\n    const textEncoder = new TextEncoder()\n\n    const parser = new JSONParser({\n      stringBufferSize: opts.stringBufferSize ?? 0,\n      handleUnescapedNewLines: opts.handleUnescapedNewLines ?? true\n    })\n\n    parser.onToken = this.handleToken.bind(this)\n    parser.onValue = () => void 0\n\n    const stream = new TransformStream({\n      transform: async (chunk, controller): Promise<void> => {\n        try {\n          if (parser.isEnded) {\n            controller.enqueue(textEncoder.encode(JSON.stringify(this.schemaInstance)))\n\n            return\n          } else {\n            parser.write(chunk)\n            controller.enqueue(textEncoder.encode(JSON.stringify(this.schemaInstance)))\n          }\n        } catch (e) {\n          console.error(`Error in the json parser transform stream: parsing chunk`, e, chunk)\n        }\n      },\n      flush: () => {\n        this.onKeyComplete &&\n          this.onKeyComplete({\n            completedPaths: this.completedPaths,\n            activePath: []\n          })\n\n        this.activePath = []\n      }\n    })\n\n    return stream\n  }\n}\n","enum TokenType {\n  LEFT_BRACE,\n  RIGHT_BRACE,\n  LEFT_BRACKET,\n  RIGHT_BRACKET,\n  COLON,\n  COMMA,\n  TRUE,\n  FALSE,\n  NULL,\n  STRING,\n  NUMBER,\n  SEPARATOR\n}\n\nexport function TokenTypeToString(tokenType: TokenType): string {\n  return [\n    \"LEFT_BRACE\",\n    \"RIGHT_BRACE\",\n    \"LEFT_BRACKET\",\n    \"RIGHT_BRACKET\",\n    \"COLON\",\n    \"COMMA\",\n    \"TRUE\",\n    \"FALSE\",\n    \"NULL\",\n    \"STRING\",\n    \"NUMBER\",\n    \"SEPARATOR\"\n  ][tokenType]\n}\n\nexport default TokenType\n","/**\n * This file has been modified -  but the majority pulled directly from\n *  https://www.npmjs.com/package/@streamparser/json\n *  https://github.com/juanjoDiaz/streamparser-json\n *\n *  Copyright (c) 2020 Juanjo Diaz\n *  https://github.com/juanjoDiaz\n *\n */\n\nimport TokenType from \"./token-type\"\n\nexport type JsonPrimitive = string | number | boolean | null\nexport type JsonKey = string | number | undefined\nexport type JsonObject = { [key: string]: JsonPrimitive | JsonStruct }\nexport type JsonArray = (JsonPrimitive | JsonStruct)[]\nexport type JsonStruct = JsonObject | JsonArray\n\nexport const enum TokenParserMode {\n  OBJECT,\n  ARRAY\n}\n\nexport interface StackElement {\n  key: JsonKey\n  value: JsonStruct\n  mode?: TokenParserMode\n  emit: boolean\n}\n\nexport interface ParsedTokenInfo {\n  token: TokenType\n  value: JsonPrimitive\n  offset?: number\n  partial?: boolean\n}\n\nexport interface ParsedElementInfo {\n  value: JsonPrimitive | JsonStruct\n  parent?: JsonStruct\n  key?: JsonKey\n  stack: StackElement[]\n}\n\nexport const enum TokenParserState {\n  VALUE,\n  KEY,\n  COLON,\n  COMMA,\n  ENDED,\n  ERROR,\n  SEPARATOR\n}\n\nfunction TokenParserStateToString(state: TokenParserState): string {\n  return [\"VALUE\", \"KEY\", \"COLON\", \"COMMA\", \"ENDED\", \"ERROR\", \"SEPARATOR\"][state]\n}\n\nexport interface TokenParserOptions {\n  paths?: string[]\n  keepStack?: boolean\n  separator?: string\n}\n\nconst defaultOpts: TokenParserOptions = {\n  paths: undefined,\n  keepStack: true,\n  separator: undefined\n}\n\nexport class TokenParserError extends Error {\n  constructor(message: string) {\n    super(message)\n    // Typescript is broken. This is a workaround\n    Object.setPrototypeOf(this, TokenParserError.prototype)\n  }\n}\n\nexport default class TokenParser {\n  private readonly paths?: (string[] | undefined)[]\n  private readonly keepStack: boolean\n  private readonly separator?: string\n  state: TokenParserState = TokenParserState.VALUE\n  mode: TokenParserMode | undefined = undefined\n  key: JsonKey = undefined\n  value: JsonStruct | undefined = undefined\n  stack: StackElement[] = []\n\n  constructor(opts?: TokenParserOptions) {\n    opts = { ...defaultOpts, ...opts }\n\n    if (opts.paths) {\n      this.paths = opts.paths.map(path => {\n        if (path === undefined || path === \"$*\") return undefined\n\n        if (!path.startsWith(\"$\"))\n          throw new TokenParserError(`Invalid selector \"${path}\". Should start with \"$\".`)\n        const pathParts = path.split(\".\").slice(1)\n        if (pathParts.includes(\"\"))\n          throw new TokenParserError(`Invalid selector \"${path}\". \"..\" syntax not supported.`)\n        return pathParts\n      })\n    }\n\n    this.keepStack = true\n    this.separator = opts.separator\n  }\n\n  private shouldEmit(): boolean {\n    if (!this.paths) return true\n\n    return this.paths.some(path => {\n      if (path === undefined) return true\n      if (path.length !== this.stack.length) return false\n\n      for (let i = 0; i < path.length - 1; i++) {\n        const selector = path[i]\n        const key = this.stack[i + 1].key\n        if (selector === \"*\") continue\n        if (selector !== key) return false\n      }\n\n      const selector = path[path.length - 1]\n      if (selector === \"*\") return true\n      return selector === this.key?.toString()\n    })\n  }\n\n  private push(): void {\n    this.stack.push({\n      key: this.key,\n      value: this.value as JsonStruct,\n      mode: this.mode,\n      emit: this.shouldEmit()\n    })\n  }\n\n  private pop(): void {\n    const value = this.value\n\n    let emit\n    ;({\n      key: this.key,\n      value: this.value,\n      mode: this.mode,\n      emit\n    } = this.stack.pop() as StackElement)\n\n    this.state = this.mode !== undefined ? TokenParserState.COMMA : TokenParserState.VALUE\n\n    this.emit(value as JsonPrimitive | JsonStruct, emit)\n  }\n\n  private emit(value: JsonPrimitive | JsonStruct, emit: boolean): void {\n    if (!this.keepStack && this.value && this.stack.every(item => !item.emit)) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      delete (this.value as JsonStruct as any)[this.key as string | number]\n    }\n\n    if (emit) {\n      this.onValue({\n        value: value,\n        key: this.key,\n        parent: this.value,\n        stack: this.stack\n      })\n    }\n\n    if (this.stack.length === 0) {\n      if (this.separator) {\n        this.state = TokenParserState.SEPARATOR\n      } else if (this.separator === undefined) {\n        this.end()\n      }\n      // else if separator === '', expect next JSON object.\n    }\n  }\n\n  public get isEnded(): boolean {\n    return this.state === TokenParserState.ENDED\n  }\n\n  public write({ token, value, partial }: Omit<ParsedTokenInfo, \"offset\">): void {\n    if (partial) {\n      return\n    }\n\n    try {\n      if (this.state === TokenParserState.VALUE) {\n        if (\n          token === TokenType.STRING ||\n          token === TokenType.NUMBER ||\n          token === TokenType.TRUE ||\n          token === TokenType.FALSE ||\n          token === TokenType.NULL\n        ) {\n          if (this.mode === TokenParserMode.OBJECT) {\n            ;(this.value as JsonObject)[this.key as string] = value\n            this.state = TokenParserState.COMMA\n          } else if (this.mode === TokenParserMode.ARRAY) {\n            ;(this.value as JsonArray).push(value)\n            this.state = TokenParserState.COMMA\n          }\n\n          this.emit(value, this.shouldEmit())\n          return\n        }\n\n        if (token === TokenType.LEFT_BRACE) {\n          this.push()\n          if (this.mode === TokenParserMode.OBJECT) {\n            this.value = (this.value as JsonObject)[this.key as string] = {}\n          } else if (this.mode === TokenParserMode.ARRAY) {\n            const val = {}\n            ;(this.value as JsonArray).push(val)\n            this.value = val\n          } else {\n            this.value = {}\n          }\n          this.mode = TokenParserMode.OBJECT\n          this.state = TokenParserState.KEY\n          this.key = undefined\n          return\n        }\n\n        if (token === TokenType.LEFT_BRACKET) {\n          this.push()\n          if (this.mode === TokenParserMode.OBJECT) {\n            this.value = (this.value as JsonObject)[this.key as string] = []\n          } else if (this.mode === TokenParserMode.ARRAY) {\n            const val: JsonArray = []\n            ;(this.value as JsonArray).push(val)\n            this.value = val\n          } else {\n            this.value = []\n          }\n          this.mode = TokenParserMode.ARRAY\n          this.state = TokenParserState.VALUE\n          this.key = 0\n          return\n        }\n\n        if (\n          this.mode === TokenParserMode.ARRAY &&\n          token === TokenType.RIGHT_BRACKET &&\n          (this.value as JsonArray).length === 0\n        ) {\n          this.pop()\n          return\n        }\n      }\n\n      if (this.state === TokenParserState.KEY) {\n        if (token === TokenType.STRING) {\n          this.key = value as string\n          this.state = TokenParserState.COLON\n          return\n        }\n\n        if (token === TokenType.RIGHT_BRACE && Object.keys(this.value as JsonObject).length === 0) {\n          this.pop()\n          return\n        }\n      }\n\n      if (this.state === TokenParserState.COLON) {\n        if (token === TokenType.COLON) {\n          this.state = TokenParserState.VALUE\n          return\n        }\n      }\n\n      if (this.state === TokenParserState.COMMA) {\n        if (token === TokenType.COMMA) {\n          if (this.mode === TokenParserMode.ARRAY) {\n            this.state = TokenParserState.VALUE\n            ;(this.key as number) += 1\n            return\n          }\n\n          if (this.mode === TokenParserMode.OBJECT) {\n            this.state = TokenParserState.KEY\n            return\n          }\n        }\n\n        if (\n          (token === TokenType.RIGHT_BRACE && this.mode === TokenParserMode.OBJECT) ||\n          (token === TokenType.RIGHT_BRACKET && this.mode === TokenParserMode.ARRAY)\n        ) {\n          this.pop()\n          return\n        }\n      }\n\n      if (this.state === TokenParserState.SEPARATOR) {\n        if (token === TokenType.SEPARATOR && value === this.separator) {\n          this.state = TokenParserState.VALUE\n          return\n        }\n      }\n\n      throw new TokenParserError(\n        `Unexpected ${TokenType[token]} (${JSON.stringify(\n          value\n        )}) in state ${TokenParserStateToString(this.state)}`\n      )\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (err: any) {\n      this.error(err)\n    }\n  }\n\n  public error(err: Error): void {\n    if (this.state !== TokenParserState.ENDED) {\n      this.state = TokenParserState.ERROR\n    }\n\n    this.onError(err)\n  }\n\n  public end(): void {\n    if (\n      (this.state !== TokenParserState.VALUE && this.state !== TokenParserState.SEPARATOR) ||\n      this.stack.length > 0\n    ) {\n      this.error(\n        new Error(\n          `Parser ended in mid-parsing (state: ${TokenParserStateToString(\n            this.state\n          )}). Either not all the data was received or the data was invalid.`\n        )\n      )\n    } else {\n      this.state = TokenParserState.ENDED\n      this.onEnd()\n    }\n  }\n\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n  public onValue(_parsedElementInfo: ParsedElementInfo): void {\n    throw new TokenParserError('Can\\'t emit data before the \"onValue\" callback has been set up.')\n  }\n\n  public onError(err: Error): void {\n    // Override me\n    throw err\n  }\n\n  public onEnd(): void {\n    // Override me\n  }\n}\n","/**\n * This file has been modified -  but the majority pulled directly from\n *  https://www.npmjs.com/package/@streamparser/json\n *  https://github.com/juanjoDiaz/streamparser-json\n *\n *  Copyright (c) 2020 Juanjo Diaz\n *  https://github.com/juanjoDiaz\n *\n */\n\nexport interface StringBuilder {\n  byteLength: number\n  appendChar: (char: number) => void\n  appendBuf: (buf: Uint8Array, start?: number, end?: number) => void\n  reset: () => void\n  toString: () => string\n}\n\nexport class NonBufferedString implements StringBuilder {\n  private decoder = new TextDecoder(\"utf-8\")\n  private strings: Array<string> = []\n  private onIncrementalString?: (str: string) => void\n\n  public byteLength = 0\n\n  constructor({ onIncrementalString }: { onIncrementalString?: (str: string) => void }) {\n    this.onIncrementalString = onIncrementalString ?? undefined\n  }\n\n  public appendChar(char: number): void {\n    this.strings.push(String.fromCharCode(char))\n    this.byteLength += 1\n    this.update()\n  }\n\n  public appendBuf(buf: Uint8Array, start = 0, end: number = buf.length): void {\n    this.strings.push(this.decoder.decode(buf.subarray(start, end)))\n    this.byteLength += end - start\n    this.update()\n  }\n\n  private update(): void {\n    if (this.onIncrementalString) this.onIncrementalString(this.toString())\n  }\n\n  public reset(): void {\n    this.strings = []\n    this.byteLength = 0\n  }\n\n  public toString(): string {\n    return this.strings.join(\"\")\n  }\n}\n\nexport class BufferedString implements StringBuilder {\n  private decoder = new TextDecoder(\"utf-8\")\n  private buffer: Uint8Array\n  private bufferOffset = 0\n  private string = \"\"\n  private onIncrementalString?: (str: string) => void\n\n  public byteLength = 0\n\n  public constructor(bufferSize: number, onIncrementalString?: (str: string) => void) {\n    this.buffer = new Uint8Array(bufferSize)\n    this.onIncrementalString = onIncrementalString ?? undefined\n  }\n\n  public appendChar(char: number): void {\n    if (this.bufferOffset >= this.buffer.length) this.flushStringBuffer()\n    this.buffer[this.bufferOffset++] = char\n    this.byteLength += 1\n  }\n\n  public appendBuf(buf: Uint8Array, start = 0, end: number = buf.length): void {\n    const size = end - start\n    if (this.bufferOffset + size > this.buffer.length) this.flushStringBuffer()\n\n    this.buffer.set(buf.subarray(start, end), this.bufferOffset)\n    this.bufferOffset += size\n    this.byteLength += size\n  }\n\n  private flushStringBuffer(): void {\n    this.string += this.decoder.decode(this.buffer.subarray(0, this.bufferOffset))\n    this.bufferOffset = 0\n    this.update()\n  }\n\n  private update(): void {\n    if (this.onIncrementalString) this.onIncrementalString(this.toString())\n  }\n\n  public reset(): void {\n    this.string = \"\"\n    this.bufferOffset = 0\n    this.byteLength = 0\n  }\n  public toString(): string {\n    this.flushStringBuffer()\n    return this.string\n  }\n}\n","export const enum charset {\n  BACKSPACE = 0x8, // \"\\b\"\n  FORM_FEED = 0xc, // \"\\f\"\n  NEWLINE = 0xa, // \"\\n\"\n  CARRIAGE_RETURN = 0xd, // \"\\r\"\n  TAB = 0x9, // \"\\t\"\n  SPACE = 0x20, //\n  EXCLAMATION_MARK = 0x21, // !\n  QUOTATION_MARK = 0x22, // \"\n  NUMBER_SIGN = 0x23, // #\n  DOLLAR_SIGN = 0x24, // $\n  PERCENT_SIGN = 0x25, // %\n  AMPERSAND = 0x26, // &\n  APOSTROPHE = 0x27, // '\n  LEFT_PARENTHESIS = 0x28, // (\n  RIGHT_PARENTHESIS = 0x29, // )\n  ASTERISK = 0x2a, // *\n  PLUS_SIGN = 0x2b, // +\n  COMMA = 0x2c, // ,\n  HYPHEN_MINUS = 0x2d, // -\n  FULL_STOP = 0x2e, // .\n  SOLIDUS = 0x2f, // /\n  DIGIT_ZERO = 0x30, // 0\n  DIGIT_ONE = 0x31, // 1\n  DIGIT_TWO = 0x32, // 2\n  DIGIT_THREE = 0x33, // 3\n  DIGIT_FOUR = 0x34, // 4\n  DIGIT_FIVE = 0x35, // 5\n  DIGIT_SIX = 0x36, // 6\n  DIGIT_SEVEN = 0x37, // 7\n  DIGIT_EIGHT = 0x38, // 8\n  DIGIT_NINE = 0x39, // 9\n  COLON = 0x3a, //  =\n  SEMICOLON = 0x3b, // ;\n  LESS_THAN_SIGN = 0x3c, // <\n  EQUALS_SIGN = 0x3d, // =\n  GREATER_THAN_SIGN = 0x3e, // >\n  QUESTION_MARK = 0x3f, // ?\n  COMMERCIAL_AT = 0x40, // @\n  LATIN_CAPITAL_LETTER_A = 0x41, // A\n  LATIN_CAPITAL_LETTER_B = 0x42, // B\n  LATIN_CAPITAL_LETTER_C = 0x43, // C\n  LATIN_CAPITAL_LETTER_D = 0x44, // D\n  LATIN_CAPITAL_LETTER_E = 0x45, // E\n  LATIN_CAPITAL_LETTER_F = 0x46, // F\n  LATIN_CAPITAL_LETTER_G = 0x47, // G\n  LATIN_CAPITAL_LETTER_H = 0x48, // H\n  LATIN_CAPITAL_LETTER_I = 0x49, // I\n  LATIN_CAPITAL_LETTER_J = 0x4a, // J\n  LATIN_CAPITAL_LETTER_K = 0x4b, // K\n  LATIN_CAPITAL_LETTER_L = 0x4c, // L\n  LATIN_CAPITAL_LETTER_M = 0x4d, // M\n  LATIN_CAPITAL_LETTER_N = 0x4e, // N\n  LATIN_CAPITAL_LETTER_O = 0x4f, // O\n  LATIN_CAPITAL_LETTER_P = 0x50, // P\n  LATIN_CAPITAL_LETTER_Q = 0x51, // Q\n  LATIN_CAPITAL_LETTER_R = 0x52, // R\n  LATIN_CAPITAL_LETTER_S = 0x53, // S\n  LATIN_CAPITAL_LETTER_T = 0x54, // T\n  LATIN_CAPITAL_LETTER_U = 0x55, // U\n  LATIN_CAPITAL_LETTER_V = 0x56, // V\n  LATIN_CAPITAL_LETTER_W = 0x57, // W\n  LATIN_CAPITAL_LETTER_X = 0x58, // X\n  LATIN_CAPITAL_LETTER_Y = 0x59, // Y\n  LATIN_CAPITAL_LETTER_Z = 0x5a, // Z\n  LEFT_SQUARE_BRACKET = 0x5b, // [\n  REVERSE_SOLIDUS = 0x5c, // \\\n  RIGHT_SQUARE_BRACKET = 0x5d, // ]\n  CIRCUMFLEX_ACCENT = 0x5e, // ^\n  LOW_LINE = 0x5f, // _\n  GRAVE_ACCENT = 0x60, // `\n  LATIN_SMALL_LETTER_A = 0x61, // a\n  LATIN_SMALL_LETTER_B = 0x62, // b\n  LATIN_SMALL_LETTER_C = 0x63, // c\n  LATIN_SMALL_LETTER_D = 0x64, // d\n  LATIN_SMALL_LETTER_E = 0x65, // e\n  LATIN_SMALL_LETTER_F = 0x66, // f\n  LATIN_SMALL_LETTER_G = 0x67, // g\n  LATIN_SMALL_LETTER_H = 0x68, // h\n  LATIN_SMALL_LETTER_I = 0x69, // i\n  LATIN_SMALL_LETTER_J = 0x6a, // j\n  LATIN_SMALL_LETTER_K = 0x6b, // k\n  LATIN_SMALL_LETTER_L = 0x6c, // l\n  LATIN_SMALL_LETTER_M = 0x6d, // m\n  LATIN_SMALL_LETTER_N = 0x6e, // n\n  LATIN_SMALL_LETTER_O = 0x6f, // o\n  LATIN_SMALL_LETTER_P = 0x70, // p\n  LATIN_SMALL_LETTER_Q = 0x71, // q\n  LATIN_SMALL_LETTER_R = 0x72, // r\n  LATIN_SMALL_LETTER_S = 0x73, // s\n  LATIN_SMALL_LETTER_T = 0x74, // t\n  LATIN_SMALL_LETTER_U = 0x75, // u\n  LATIN_SMALL_LETTER_V = 0x76, // v\n  LATIN_SMALL_LETTER_W = 0x77, // w\n  LATIN_SMALL_LETTER_X = 0x78, // x\n  LATIN_SMALL_LETTER_Y = 0x79, // y\n  LATIN_SMALL_LETTER_Z = 0x7a, // z\n  LEFT_CURLY_BRACKET = 0x7b, // {\n  VERTICAL_LINE = 0x7c, // |\n  RIGHT_CURLY_BRACKET = 0x7d, // }\n  TILDE = 0x7e // ~\n}\n\nexport const escapedSequences: { [key: number]: number } = {\n  [charset.QUOTATION_MARK]: charset.QUOTATION_MARK,\n  [charset.REVERSE_SOLIDUS]: charset.REVERSE_SOLIDUS,\n  [charset.SOLIDUS]: charset.SOLIDUS,\n  [charset.LATIN_SMALL_LETTER_B]: charset.BACKSPACE,\n  [charset.LATIN_SMALL_LETTER_F]: charset.FORM_FEED,\n  [charset.LATIN_SMALL_LETTER_N]: charset.NEWLINE,\n  [charset.LATIN_SMALL_LETTER_R]: charset.CARRIAGE_RETURN,\n  [charset.LATIN_SMALL_LETTER_T]: charset.TAB\n}\n","/**\n * This file has been modified -  but the majority pulled directly from\n *  https://www.npmjs.com/package/@streamparser/json\n *  https://github.com/juanjoDiaz/streamparser-json\n *\n *  Copyright (c) 2020 Juanjo Diaz\n *  https://github.com/juanjoDiaz\n *\n */\n\nimport { BufferedString, NonBufferedString, type StringBuilder } from \"./buffered-string\"\nimport type { ParsedTokenInfo } from \"./token-parser\"\nimport TokenType from \"./token-type\"\nimport { charset, escapedSequences } from \"./utf-8.js\"\n\n// Tokenizer States\nconst enum TokenizerStates {\n  START,\n  ENDED,\n  ERROR,\n  TRUE1,\n  TRUE2,\n  TRUE3,\n  FALSE1,\n  FALSE2,\n  FALSE3,\n  FALSE4,\n  NULL1,\n  NULL2,\n  NULL3,\n  STRING_DEFAULT,\n  STRING_AFTER_BACKSLASH,\n  STRING_UNICODE_DIGIT_1,\n  STRING_UNICODE_DIGIT_2,\n  STRING_UNICODE_DIGIT_3,\n  STRING_UNICODE_DIGIT_4,\n  STRING_INCOMPLETE_CHAR,\n  NUMBER_AFTER_INITIAL_MINUS,\n  NUMBER_AFTER_INITIAL_ZERO,\n  NUMBER_AFTER_INITIAL_NON_ZERO,\n  NUMBER_AFTER_FULL_STOP,\n  NUMBER_AFTER_DECIMAL,\n  NUMBER_AFTER_E,\n  NUMBER_AFTER_E_AND_SIGN,\n  NUMBER_AFTER_E_AND_DIGIT,\n  SEPARATOR\n}\n\nfunction TokenizerStateToString(tokenizerState: TokenizerStates): string {\n  return [\n    \"START\",\n    \"ENDED\",\n    \"ERROR\",\n    \"TRUE1\",\n    \"TRUE2\",\n    \"TRUE3\",\n    \"FALSE1\",\n    \"FALSE2\",\n    \"FALSE3\",\n    \"FALSE4\",\n    \"NULL1\",\n    \"NULL2\",\n    \"NULL3\",\n    \"STRING_DEFAULT\",\n    \"STRING_AFTER_BACKSLASH\",\n    \"STRING_UNICODE_DIGIT_1\",\n    \"STRING_UNICODE_DIGIT_2\",\n    \"STRING_UNICODE_DIGIT_3\",\n    \"STRING_UNICODE_DIGIT_4\",\n    \"STRING_INCOMPLETE_CHAR\",\n    \"NUMBER_AFTER_INITIAL_MINUS\",\n    \"NUMBER_AFTER_INITIAL_ZERO\",\n    \"NUMBER_AFTER_INITIAL_NON_ZERO\",\n    \"NUMBER_AFTER_FULL_STOP\",\n    \"NUMBER_AFTER_DECIMAL\",\n    \"NUMBER_AFTER_E\",\n    \"NUMBER_AFTER_E_AND_SIGN\",\n    \"NUMBER_AFTER_E_AND_DIGIT\",\n    \"SEPARATOR\"\n  ][tokenizerState]\n}\n\nexport interface TokenizerOptions {\n  stringBufferSize?: number\n  numberBufferSize?: number\n  separator?: string\n  handleUnescapedNewLines?: boolean\n}\n\nconst defaultOpts: TokenizerOptions = {\n  stringBufferSize: 0,\n  numberBufferSize: 0,\n  separator: undefined,\n  handleUnescapedNewLines: false\n}\n\nexport class TokenizerError extends Error {\n  constructor(message: string) {\n    super(message)\n    // Typescript is broken. This is a workaround\n    Object.setPrototypeOf(this, TokenizerError.prototype)\n  }\n}\n\nexport default class Tokenizer {\n  private state = TokenizerStates.START\n\n  private handleUnescapedNewLines?: boolean\n  private separator?: string\n  private separatorBytes?: Uint8Array\n  private separatorIndex = 0\n  private bufferedString: StringBuilder\n  private bufferedNumber: StringBuilder\n\n  private unicode?: string // unicode escapes\n  private highSurrogate?: number\n  private bytes_remaining = 0 // number of bytes remaining in multi byte utf8 char to read after split boundary\n  private bytes_in_sequence = 0 // bytes in multi byte utf8 char to read\n  private char_split_buffer = new Uint8Array(4) // for rebuilding chars split before boundary is reached\n  private encoder = new TextEncoder()\n  private offset = -1\n\n  constructor(opts?: TokenizerOptions) {\n    opts = { ...defaultOpts, ...opts }\n\n    const onIncrementalString = str => {\n      this.onToken({\n        token: TokenType.STRING,\n        value: str,\n        partial: true\n      })\n    }\n\n    this.bufferedString =\n      opts?.stringBufferSize && opts.stringBufferSize > 0\n        ? new BufferedString(opts.stringBufferSize)\n        : new NonBufferedString({\n            onIncrementalString\n          })\n\n    this.bufferedNumber =\n      opts?.numberBufferSize && opts.numberBufferSize > 0\n        ? new BufferedString(opts.numberBufferSize, onIncrementalString)\n        : new NonBufferedString({})\n\n    this.handleUnescapedNewLines = opts?.handleUnescapedNewLines ?? false\n    this.separator = opts?.separator\n    this.separatorBytes = opts?.separator ? this.encoder.encode(opts.separator) : undefined\n  }\n\n  public get isEnded(): boolean {\n    return this.state === TokenizerStates.ENDED\n  }\n\n  public write(input: Iterable<number> | string): void {\n    try {\n      let buffer: Uint8Array\n      if (input instanceof Uint8Array) {\n        buffer = input\n      } else if (typeof input === \"string\") {\n        buffer = this.encoder.encode(input)\n      } else if ((typeof input === \"object\" && \"buffer\" in input) || Array.isArray(input)) {\n        buffer = Uint8Array.from(input)\n      } else {\n        throw new TypeError(\n          \"Unexpected type. The `write` function only accepts Arrays, TypedArrays and Strings.\"\n        )\n      }\n\n      for (let i = 0; i < buffer.length; i += 1) {\n        const n = buffer[i] // get current byte from buffer\n        switch (this.state) {\n          case TokenizerStates.START:\n            this.offset += 1\n\n            if (this.separatorBytes && n === this.separatorBytes[0]) {\n              if (this.separatorBytes.length === 1) {\n                this.state = TokenizerStates.START\n                this.onToken({\n                  token: TokenType.SEPARATOR,\n                  value: this.separator as string,\n                  offset: this.offset + this.separatorBytes.length - 1\n                })\n                continue\n              }\n              this.state = TokenizerStates.SEPARATOR\n              continue\n            }\n\n            if (\n              n === charset.SPACE ||\n              n === charset.NEWLINE ||\n              n === charset.CARRIAGE_RETURN ||\n              n === charset.TAB\n            ) {\n              // whitespace\n              continue\n            }\n\n            if (n === charset.LEFT_CURLY_BRACKET) {\n              this.onToken({\n                token: TokenType.LEFT_BRACE,\n                value: \"{\",\n                offset: this.offset\n              })\n              continue\n            }\n            if (n === charset.RIGHT_CURLY_BRACKET) {\n              this.onToken({\n                token: TokenType.RIGHT_BRACE,\n                value: \"}\",\n                offset: this.offset\n              })\n              continue\n            }\n            if (n === charset.LEFT_SQUARE_BRACKET) {\n              this.onToken({\n                token: TokenType.LEFT_BRACKET,\n                value: \"[\",\n                offset: this.offset\n              })\n              continue\n            }\n            if (n === charset.RIGHT_SQUARE_BRACKET) {\n              this.onToken({\n                token: TokenType.RIGHT_BRACKET,\n                value: \"]\",\n                offset: this.offset\n              })\n              continue\n            }\n            if (n === charset.COLON) {\n              this.onToken({\n                token: TokenType.COLON,\n                value: \":\",\n                offset: this.offset\n              })\n              continue\n            }\n            if (n === charset.COMMA) {\n              this.onToken({\n                token: TokenType.COMMA,\n                value: \",\",\n                offset: this.offset\n              })\n              continue\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_T) {\n              this.state = TokenizerStates.TRUE1\n              continue\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_F) {\n              this.state = TokenizerStates.FALSE1\n              continue\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_N) {\n              this.state = TokenizerStates.NULL1\n              continue\n            }\n\n            if (n === charset.QUOTATION_MARK) {\n              this.bufferedString.reset()\n              this.state = TokenizerStates.STRING_DEFAULT\n              continue\n            }\n\n            if (n >= charset.DIGIT_ONE && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.reset()\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO\n              continue\n            }\n\n            if (n === charset.DIGIT_ZERO) {\n              this.bufferedNumber.reset()\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_ZERO\n              continue\n            }\n\n            if (n === charset.HYPHEN_MINUS) {\n              this.bufferedNumber.reset()\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_MINUS\n              continue\n            }\n\n            break\n          // STRING\n          case TokenizerStates.STRING_DEFAULT:\n            if (this.handleUnescapedNewLines && n === charset.NEWLINE) {\n              this.bufferedString.appendChar(charset.REVERSE_SOLIDUS) // Appends '\\'\n              this.bufferedString.appendChar(charset.LATIN_SMALL_LETTER_N) // Appends 'n'\n              continue\n            }\n\n            if (n === charset.QUOTATION_MARK) {\n              const string = this.bufferedString.toString()\n              this.state = TokenizerStates.START\n              this.onToken({\n                token: TokenType.STRING,\n                value: string,\n                offset: this.offset\n              })\n              this.offset += this.bufferedString.byteLength + 1\n              continue\n            }\n\n            if (n === charset.REVERSE_SOLIDUS) {\n              this.state = TokenizerStates.STRING_AFTER_BACKSLASH\n              continue\n            }\n\n            if (n >= 128) {\n              // Parse multi byte (>=128) chars one at a time\n              if (n >= 194 && n <= 223) {\n                this.bytes_in_sequence = 2\n              } else if (n <= 239) {\n                this.bytes_in_sequence = 3\n              } else {\n                this.bytes_in_sequence = 4\n              }\n\n              if (this.bytes_in_sequence <= buffer.length - i) {\n                // if bytes needed to complete char fall outside buffer length, we have a boundary split\n                this.bufferedString.appendBuf(buffer, i, i + this.bytes_in_sequence)\n                i += this.bytes_in_sequence - 1\n                continue\n              }\n\n              this.bytes_remaining = i + this.bytes_in_sequence - buffer.length\n              this.char_split_buffer.set(buffer.subarray(i))\n              i = buffer.length - 1\n              this.state = TokenizerStates.STRING_INCOMPLETE_CHAR\n              continue\n            }\n\n            if (n >= charset.SPACE) {\n              this.bufferedString.appendChar(n)\n              continue\n            }\n\n            break\n          case TokenizerStates.STRING_INCOMPLETE_CHAR:\n            // check for carry over of a multi byte char split between data chunks\n            // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n            this.char_split_buffer.set(\n              buffer.subarray(i, i + this.bytes_remaining),\n              this.bytes_in_sequence - this.bytes_remaining\n            )\n            this.bufferedString.appendBuf(this.char_split_buffer, 0, this.bytes_in_sequence)\n            i = this.bytes_remaining - 1\n            this.state = TokenizerStates.STRING_DEFAULT\n            continue\n          case TokenizerStates.STRING_AFTER_BACKSLASH:\n            if (escapedSequences?.[n]) {\n              this.bufferedString.appendChar(escapedSequences[n])\n              this.state = TokenizerStates.STRING_DEFAULT\n              continue\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_U) {\n              this.unicode = \"\"\n              this.state = TokenizerStates.STRING_UNICODE_DIGIT_1\n              continue\n            }\n\n            break\n          case TokenizerStates.STRING_UNICODE_DIGIT_1:\n          case TokenizerStates.STRING_UNICODE_DIGIT_2:\n          case TokenizerStates.STRING_UNICODE_DIGIT_3:\n            if (\n              (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) ||\n              (n >= charset.LATIN_CAPITAL_LETTER_A && n <= charset.LATIN_CAPITAL_LETTER_F) ||\n              (n >= charset.LATIN_SMALL_LETTER_A && n <= charset.LATIN_SMALL_LETTER_F)\n            ) {\n              this.unicode += String.fromCharCode(n)\n              this.state += 1\n              continue\n            }\n            break\n          case TokenizerStates.STRING_UNICODE_DIGIT_4:\n            if (\n              (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) ||\n              (n >= charset.LATIN_CAPITAL_LETTER_A && n <= charset.LATIN_CAPITAL_LETTER_F) ||\n              (n >= charset.LATIN_SMALL_LETTER_A && n <= charset.LATIN_SMALL_LETTER_F)\n            ) {\n              const intVal = parseInt(this.unicode + String.fromCharCode(n), 16)\n              if (this.highSurrogate === undefined) {\n                if (intVal >= 0xd800 && intVal <= 0xdbff) {\n                  //<55296,56319> - highSurrogate\n                  this.highSurrogate = intVal\n                } else {\n                  this.bufferedString.appendBuf(this.encoder.encode(String.fromCharCode(intVal)))\n                }\n              } else {\n                if (intVal >= 0xdc00 && intVal <= 0xdfff) {\n                  //<56320,57343> - lowSurrogate\n                  this.bufferedString.appendBuf(\n                    this.encoder.encode(String.fromCharCode(this.highSurrogate, intVal))\n                  )\n                } else {\n                  this.bufferedString.appendBuf(\n                    this.encoder.encode(String.fromCharCode(this.highSurrogate))\n                  )\n                }\n                this.highSurrogate = undefined\n              }\n              this.state = TokenizerStates.STRING_DEFAULT\n              continue\n            }\n            break\n          // Number\n          case TokenizerStates.NUMBER_AFTER_INITIAL_MINUS:\n            if (n === charset.DIGIT_ZERO) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_ZERO\n              continue\n            }\n\n            if (n >= charset.DIGIT_ONE && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO\n              continue\n            }\n\n            break\n          case TokenizerStates.NUMBER_AFTER_INITIAL_ZERO:\n            if (n === charset.FULL_STOP) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_FULL_STOP\n              continue\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_E || n === charset.LATIN_CAPITAL_LETTER_E) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_E\n              continue\n            }\n\n            i -= 1\n            this.state = TokenizerStates.START\n            this.emitNumber()\n            continue\n          case TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n)\n              continue\n            }\n\n            if (n === charset.FULL_STOP) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_FULL_STOP\n              continue\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_E || n === charset.LATIN_CAPITAL_LETTER_E) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_E\n              continue\n            }\n\n            i -= 1\n            this.state = TokenizerStates.START\n            this.emitNumber()\n            continue\n          case TokenizerStates.NUMBER_AFTER_FULL_STOP:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_DECIMAL\n              continue\n            }\n\n            break\n          case TokenizerStates.NUMBER_AFTER_DECIMAL:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n)\n              continue\n            }\n\n            if (n === charset.LATIN_SMALL_LETTER_E || n === charset.LATIN_CAPITAL_LETTER_E) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_E\n              continue\n            }\n\n            i -= 1\n            this.state = TokenizerStates.START\n            this.emitNumber()\n            continue\n          // @ts-expect error fall through case\n          case TokenizerStates.NUMBER_AFTER_E:\n            if (n === charset.PLUS_SIGN || n === charset.HYPHEN_MINUS) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_E_AND_SIGN\n              continue\n            }\n          // @ts-expect error fall through case\n          case TokenizerStates.NUMBER_AFTER_E_AND_SIGN:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n)\n              this.state = TokenizerStates.NUMBER_AFTER_E_AND_DIGIT\n              continue\n            }\n\n            break\n          case TokenizerStates.NUMBER_AFTER_E_AND_DIGIT:\n            if (n >= charset.DIGIT_ZERO && n <= charset.DIGIT_NINE) {\n              this.bufferedNumber.appendChar(n)\n              continue\n            }\n\n            i -= 1\n            this.state = TokenizerStates.START\n            this.emitNumber()\n            continue\n          // TRUE\n          case TokenizerStates.TRUE1:\n            if (n === charset.LATIN_SMALL_LETTER_R) {\n              this.state = TokenizerStates.TRUE2\n              continue\n            }\n            break\n          case TokenizerStates.TRUE2:\n            if (n === charset.LATIN_SMALL_LETTER_U) {\n              this.state = TokenizerStates.TRUE3\n              continue\n            }\n            break\n          case TokenizerStates.TRUE3:\n            if (n === charset.LATIN_SMALL_LETTER_E) {\n              this.state = TokenizerStates.START\n              this.onToken({\n                token: TokenType.TRUE,\n                value: true,\n                offset: this.offset\n              })\n              this.offset += 3\n              continue\n            }\n            break\n          // FALSE\n          case TokenizerStates.FALSE1:\n            if (n === charset.LATIN_SMALL_LETTER_A) {\n              this.state = TokenizerStates.FALSE2\n              continue\n            }\n            break\n          case TokenizerStates.FALSE2:\n            if (n === charset.LATIN_SMALL_LETTER_L) {\n              this.state = TokenizerStates.FALSE3\n              continue\n            }\n            break\n          case TokenizerStates.FALSE3:\n            if (n === charset.LATIN_SMALL_LETTER_S) {\n              this.state = TokenizerStates.FALSE4\n              continue\n            }\n            break\n          case TokenizerStates.FALSE4:\n            if (n === charset.LATIN_SMALL_LETTER_E) {\n              this.state = TokenizerStates.START\n              this.onToken({\n                token: TokenType.FALSE,\n                value: false,\n                offset: this.offset\n              })\n              this.offset += 4\n              continue\n            }\n            break\n          // NULL\n          case TokenizerStates.NULL1:\n            if (n === charset.LATIN_SMALL_LETTER_U) {\n              this.state = TokenizerStates.NULL2\n              continue\n            }\n            break\n          case TokenizerStates.NULL2:\n            if (n === charset.LATIN_SMALL_LETTER_L) {\n              this.state = TokenizerStates.NULL3\n              continue\n            }\n            break\n          case TokenizerStates.NULL3:\n            if (n === charset.LATIN_SMALL_LETTER_L) {\n              this.state = TokenizerStates.START\n              this.onToken({\n                token: TokenType.NULL,\n                value: null,\n                offset: this.offset\n              })\n              this.offset += 3\n              continue\n            }\n            break\n          case TokenizerStates.SEPARATOR:\n            this.separatorIndex += 1\n            if (!this.separatorBytes || n !== this.separatorBytes[this.separatorIndex]) {\n              break\n            }\n            if (this.separatorIndex === this.separatorBytes.length - 1) {\n              this.state = TokenizerStates.START\n              this.onToken({\n                token: TokenType.SEPARATOR,\n                value: this.separator as string,\n                offset: this.offset + this.separatorIndex\n              })\n              this.separatorIndex = 0\n            }\n            continue\n          case TokenizerStates.ENDED:\n            if (\n              n === charset.SPACE ||\n              n === charset.NEWLINE ||\n              n === charset.CARRIAGE_RETURN ||\n              n === charset.TAB\n            ) {\n              // whitespace\n              continue\n            }\n        }\n\n        throw new TokenizerError(\n          `Unexpected \"${String.fromCharCode(\n            n\n          )}\" at position \"${i}\" in state ${TokenizerStateToString(this.state)}`\n        )\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (err: any) {\n      this.error(err)\n    }\n  }\n\n  private emitNumber(): void {\n    this.onToken({\n      token: TokenType.NUMBER,\n      value: this.parseNumber(this.bufferedNumber.toString()),\n      offset: this.offset\n    })\n    this.offset += this.bufferedNumber.byteLength - 1\n  }\n\n  protected parseNumber(numberStr: string): number {\n    return Number(numberStr)\n  }\n\n  public error(err: Error): void {\n    if (this.state !== TokenizerStates.ENDED) {\n      this.state = TokenizerStates.ERROR\n    }\n\n    this.onError(err)\n  }\n\n  public end(): void {\n    switch (this.state) {\n      case TokenizerStates.NUMBER_AFTER_INITIAL_ZERO:\n      case TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO:\n      case TokenizerStates.NUMBER_AFTER_DECIMAL:\n      case TokenizerStates.NUMBER_AFTER_E_AND_DIGIT:\n        this.state = TokenizerStates.ENDED\n        this.emitNumber()\n        this.onEnd()\n        break\n      case TokenizerStates.START:\n      case TokenizerStates.ERROR:\n      case TokenizerStates.SEPARATOR:\n        this.state = TokenizerStates.ENDED\n        this.onEnd()\n        break\n      default:\n        this.error(\n          new TokenizerError(\n            `Tokenizer ended in the middle of a token (state: ${TokenizerStateToString(\n              this.state\n            )}). Either not all the data was received or the data was invalid.`\n          )\n        )\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public onToken(parsedToken: ParsedTokenInfo): void {\n    // Override me\n    throw new TokenizerError('Can\\'t emit tokens before the \"onToken\" callback has been set up.')\n  }\n\n  public onError(err: Error): void {\n    // Override me\n    throw err\n  }\n\n  public onEnd(): void {\n    // Override me\n  }\n}\n","import TokenParser, {\n  JsonKey,\n  ParsedElementInfo,\n  ParsedTokenInfo,\n  StackElement,\n  TokenParserMode,\n  TokenParserState,\n  type TokenParserOptions\n} from \"./token-parser\"\nimport TokenType from \"./token-type\"\nimport Tokenizer, { type TokenizerOptions } from \"./tokenizer\"\n\nexport interface JSONParserOptions extends TokenizerOptions, TokenParserOptions {}\n\nexport default class JSONParser {\n  private tokenizer: Tokenizer\n  private tokenParser: TokenParser\n\n  constructor(opts: JSONParserOptions = {}) {\n    this.tokenizer = new Tokenizer(opts)\n    this.tokenParser = new TokenParser(opts)\n\n    this.tokenizer.onToken = this.tokenParser.write.bind(this.tokenParser)\n    this.tokenizer.onEnd = () => {\n      if (!this.tokenParser.isEnded) this.tokenParser.end()\n    }\n\n    this.tokenParser.onError = this.tokenizer.error.bind(this.tokenizer)\n    this.tokenParser.onEnd = () => {\n      if (!this.tokenizer.isEnded) this.tokenizer.end()\n    }\n  }\n\n  public get isEnded(): boolean {\n    return this.tokenizer.isEnded && this.tokenParser.isEnded\n  }\n\n  public write(input: Iterable<number> | string): void {\n    this.tokenizer.write(input)\n  }\n\n  public end(): void {\n    this.tokenizer.end()\n  }\n\n  public set onToken(\n    cb: (parsedTokenInfo: {\n      parser: {\n        state: TokenParserState\n        key: JsonKey\n        mode: TokenParserMode | undefined\n        stack: StackElement[]\n      }\n      tokenizer: ParsedTokenInfo\n    }) => void\n  ) {\n    this.tokenizer.onToken = parsedToken => {\n      const valueTokenTypes = [\n        TokenType.STRING,\n        TokenType.NUMBER,\n        TokenType.TRUE,\n        TokenType.FALSE,\n        TokenType.NULL\n      ]\n\n      if (\n        this.tokenParser.state === TokenParserState.VALUE &&\n        valueTokenTypes.includes(parsedToken.token)\n      ) {\n        cb({\n          parser: {\n            state: this.tokenParser.state,\n            key: this.tokenParser.key,\n            mode: this.tokenParser.mode,\n            stack: this.tokenParser.stack\n          },\n          tokenizer: parsedToken\n        })\n      }\n\n      this.tokenParser.write(parsedToken)\n    }\n  }\n\n  public set onValue(cb: (parsedElementInfo: ParsedElementInfo) => void) {\n    this.tokenParser.onValue = cb\n  }\n\n  public set onError(cb: (err: Error) => void) {\n    this.tokenizer.onError = cb\n  }\n\n  public set onEnd(cb: () => void) {\n    this.tokenParser.onEnd = () => {\n      if (!this.tokenizer.isEnded) this.tokenizer.end()\n      cb.call(this.tokenParser)\n    }\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","SchemaStream","__toCommonJS","import_ramda","TokenType","token_type_default","TokenType","TokenParserStateToString","state","defaultOpts","TokenParserError","_TokenParserError","message","TokenParser","opts","__publicField","path","pathParts","i","selector","key","value","emit","item","token","partial","token_type_default","val","err","_parsedElementInfo","NonBufferedString","onIncrementalString","__publicField","char","buf","start","end","BufferedString","bufferSize","size","escapedSequences","TokenizerStateToString","tokenizerState","defaultOpts","TokenizerError","_TokenizerError","message","Tokenizer","opts","__publicField","onIncrementalString","str","token_type_default","BufferedString","NonBufferedString","input","buffer","i","n","string","escapedSequences","intVal","err","numberStr","parsedToken","JSONParser","opts","__publicField","Tokenizer","TokenParser","input","cb","parsedToken","valueTokenTypes","token_type_default","SchemaStream","schema","opts","__publicField","defaultData","onKeyComplete","typeDefaults","type","obj","key","stack","valuePath","token","value","partial","lens","updatedValue","updatedSchemaInstance","e","textEncoder","parser","JSONParser","chunk","controller"]}